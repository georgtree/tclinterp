'\"
'\" '\" Copyright (c) George Yashin
'\"
.TH "tclinterp" 3tcl 0\&.1 "tcl_tools" "Tcl wrapper for C interpolation procedures"
.SH NAME
tclinterp - Commands in namespace tclinterp
.SH SYNOPSIS
\fBarray2list\fP \fIarray length\fP
.br
\fBarrays2lists\fP \fIvarNames arrays lengths\fP
.br
\fBdeleteArrays\fP \fI?args?\fP
.br
\fBdeleteDoubleps\fP \fI?args?\fP
.br
\fBinterpLagr1d\fP \fI?args?\fP
.br
\fBinterpLeast1d\fP \fI?args?\fP
.br
\fBinterpLeast1dDer\fP \fI?args?\fP
.br
\fBinterpLin1d\fP \fI?args?\fP
.br
\fBinterpNear1d\fP \fI?args?\fP
.br
\fBlist2array\fP \fIlist\fP
.br
\fBlists2arrays\fP \fIvarNames lists\fP
.br
\fBnewArrays\fP \fIvarNames lengths\fP
.br
\fBnewDoubleps\fP \fIvarNames\fP
.br
.SH ::TCLINTERP
.SH COMMANDS
.PP
.RS -4n
\fBarray2list\fR (::tclinterp)
.RE
.PP
Create list from doubleArray object
.RS 4n\fBarray2list\fP \fIarray length\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
array
DoubleArray object\&.
.TP
length
Number of elements in doubleArray\&.
.RE
.PP
\fBReturn value\fR
.PP
list
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::array2list {array length} {

    # Create list from doubleArray object
    #  array - doubleArray object
    #  length - number of elements in doubleArray
    # Returns: list
    for {set i 0} {$i<$length} {incr i} {
        lappend list [::tclinterp::doubleArray_getitem $array $i]
    }
    return $list
}
.fi
.RE
.PP
.RS -4n
\fBarrays2lists\fR (::tclinterp)
.RE
.PP
Create lists from doubleArray objects, and set these lists to variables
.RS 4n\fBarrays2lists\fP \fIvarNames arrays lengths\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
varNames
List of variables names\&.
.TP
arrays
List of doubleArray\&.
.TP
lengths
List of doubleArray lengths\&.
.RE
.PP
\fBReturn value\fR
.PP
variables with lists are set in caller's scope
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::arrays2lists {varNames arrays lengths} {

    # Create lists from doubleArray objects, and set these lists to variables
    #  varNames - list of variables names
    #  arrays - list of doubleArray
    #  lengths - list of doubleArray lengths
    # Returns: variables with lists are set in caller's scope
    if {[llength $varNames]!=[llength $arrays]} {
        error "Length of varName list '[llength $varNames]' must be equal to length of array list '[llength $arrays]'"
    } elseif {[llength $varNames]!=[llength $lengths]} {
        error "Length of varName list '[llength $varNames]' must be equal to length of lengths list '[llength $lengths]'"
    }
    foreach varName $varNames array $arrays length $lengths {
        uplevel 1 [list set $varName [::tclinterp::array2list $array $length]]
    }
    return
}
.fi
.RE
.PP
.RS -4n
\fBdeleteArrays\fR (::tclinterp)
.RE
.PP
Deletes doubleArray objects
.RS 4n\fBdeleteArrays\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
args
List of arrays objects\&.
.RE
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::deleteArrays {args} {

    # Deletes doubleArray objects
    #  args - list of arrays objects
    foreach arg $args {
        ::tclinterp::delete_doubleArray $arg
    }
    return
}
.fi
.RE
.PP
.RS -4n
\fBdeleteDoubleps\fR (::tclinterp)
.RE
.PP
Deletes doublep objects
.RS 4n\fBdeleteDoubleps\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
args
List of doublep objects\&.
.RE
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::deleteDoubleps {args} {

    # Deletes doublep objects
    #  args - list of doublep objects
    foreach arg $args {
        ::tclinterp::delete_doublep $arg
    }
    return
}
.fi
.RE
.PP
.RS -4n
\fBinterpLagr1d\fR (::tclinterp)
.RE
.PP
Does Lagrange polynomial one-dimensional interpolation\&.
.RS 4n\fBinterpLagr1d\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-x
List of independent variable (x) values\&.
.TP
-xi
List of independent variable interpolation (xi) values\&.
.TP
-y
List of dependent variable (y) values\&.
.RE
.PP
\fBReturn value\fR
.PP
list of interpolated dependent variable values, yi, at xi
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::interpLagr1d {args} {

    # Does Lagrange polynomial one-dimensional interpolation\&.
    #  -x - list of independent variable (x) values
    #  -y - list of dependent variable (y) values
    #  -xi - list of independent variable interpolation (xi) values
    # Returns: list of interpolated dependent variable values, `yi`, at `xi`
    set arguments [argparse {
        {-x= -required}
        {-y= -required}
        {-xi= -required}
    }]
    set xLen [llength $x]
    set yLen [llength $y]
    set xiLen [llength $xi]
    if {$xLen!=$yLen} {
        error "Length of y '$yLen' must be equal to x '$xLen'"
    } elseif {$xiLen==0} {
        error "Length of interpolation points list xi must be more than zero"
    }
    ::tclinterp::lists2arrays [list xArray yArray xiArray] [list $x $y $xi]
    set yiArray [::tclinterp::interp_lagrange 1 $xLen $xArray $yArray $xiLen $xiArray]
    set yiList [::tclinterp::array2list $yiArray $xiLen]
    ::tclinterp::deleteArrays $xArray $yArray $xiArray $yiArray
    return $yiList
}
.fi
.RE
.PP
.RS -4n
\fBinterpLeast1d\fR (::tclinterp)
.RE
.PP
Does least squares polynomial one-dimensional interpolation\&.
.RS 4n\fBinterpLeast1d\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-coeffs
Select the alternative output option\&.
.TP
-nterms
Number of terms of interpolation polynom, default is 3\&.
.TP
-w
List of weights, optional\&.
.TP
-x
List of independent variable (x) values\&.
.TP
-xi
List of independent variable interpolation (xi) values\&.
.TP
-y
List of dependent variable (y) values\&.
.RE
.PP
\fBReturn value\fR
.PP
list of interpolated dependent variable values, yi, at xi\&. If -coeffs switch is in args, the output
is dictionary that contains yi values under yi key, and the values of interpolation polynom coefficients under
the keys b, c and d\&.
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::interpLeast1d {args} {

    # Does least squares polynomial one-dimensional interpolation\&.
    #  -x - list of independent variable (x) values
    #  -y - list of dependent variable (y) values
    #  -xi - list of independent variable interpolation (xi) values
    #  -w - list of weights, optional
    #  -nterms - number of terms of interpolation polynom, default is 3
    #  -coeffs - select the alternative output option
    # Returns: list of interpolated dependent variable values, `yi`, at `xi`\&. If `-coeffs` switch is in args, the output
    # is dictionary that contains `yi` values under `yi` key, and the values of interpolation polynom coefficients under
    # the keys `b`, `c` and `d`\&.
    set arguments [argparse {
        {-x= -required}
        {-y= -required}
        {-xi= -required}
        -w=
        {-nterms= -default 3}
        -coeffs
    }]
    set xLen [llength $x]
    set yLen [llength $y]
    if {[info exists w]} {
        set wLen [llength $w]
    } else {
        set wLen [llength $x]
        set w [lrepeat $wLen 1]
    }
    set xiLen [llength $xi]
    if {$xLen!=$yLen} {
        error "Length of y '$yLen' must be equal to x '$xLen'"
    } elseif {$xLen!=$wLen} {
        error "Length of w '$wLen' must be equal to x '$xLen'"
    } elseif {$xiLen==0} {
        error "Length of interpolation points list xi must be more than zero"
    } elseif {[string is integer -strict $nterms]==0} {
        error "Number of terms -nterms '$nterms' must be of integer type"
    } elseif {$nterms<=0} {
        error "Number of terms -nterms must be more than zero"
    }
    ::tclinterp::lists2arrays [list xArray yArray wArray xiArray] [list $x $y $w $xi]
    ::tclinterp::newArrays [list b c d] [list $nterms $nterms $nterms]
    # create polynomial coefficients for given data
    ::tclinterp::least_set $xLen $xArray $yArray $wArray $nterms $b $c $d
    # calculate polynomial value for each xi value
    for {set i 0} {$i<$xiLen} {incr i} {
        set iElem [::tclinterp::least_val $nterms $b $c $d [@ $xi $i]]
        lappend yiList $iElem
    }
    if {[info exists coeffs]} {
        ::tclinterp::arrays2lists [list bList cList dList] [list $b $c $d] [list $nterms $nterms $nterms]
        ::tclinterp::deleteArrays $b $c $d $xArray $yArray $xiArray
        return [dcreate yi $yiList coeffs [dcreate b $bList c $cList d $dList]]
    } else {
        ::tclinterp::deleteArrays $b $c $d $xArray $yArray $xiArray
        return $yiList
    }
    return
}
.fi
.RE
.PP
.RS -4n
\fBinterpLeast1dDer\fR (::tclinterp)
.RE
.PP
Does least squares polynomial one-dimensional interpolation with calculation of its derivative\&.
.RS 4n\fBinterpLeast1dDer\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-coeffs
Select the alternative output option\&.
.TP
-nterms
Number of terms of interpolation polynom, default is 3\&.
.TP
-w
List of weights, optional\&.
.TP
-x
List of independent variable (x) values\&.
.TP
-xi
List of independent variable interpolation (xi) values\&.
.TP
-y
List of dependent variable (y) values\&.
.RE
.PP
\fBReturn value\fR
.PP
dict of interpolated dependent variable values and its derivatives under yi and yiDer keys\&. If
-coeffs switch is in args, the output is dictionary that contains yi values under yi key, yi derivatives
under yiDer key, and the values of interpolation polynom coefficients under the keys b, c and d\&.
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::interpLeast1dDer {args} {

    # Does least squares polynomial one-dimensional interpolation with calculation of its derivative\&.
    #  -x - list of independent variable (x) values
    #  -y - list of dependent variable (y) values
    #  -xi - list of independent variable interpolation (xi) values
    #  -w - list of weights, optional
    #  -nterms - number of terms of interpolation polynom, default is 3
    #  -coeffs - select the alternative output option
    # Returns: dict of interpolated dependent variable values and its derivatives under `yi` and `yiDer` keys\&. If
    # `-coeffs` switch is in args, the output is dictionary that contains `yi` values under `yi` key, `yi` derivatives
    # under `yiDer` key, and the values of interpolation polynom coefficients under the keys `b`, `c` and `d`\&.
    set arguments [argparse {
        {-x= -required}
        {-y= -required}
        {-xi= -required}
        -w=
        {-nterms= -default 3}
        -coeffs
    }]
    set xLen [llength $x]
    set yLen [llength $y]
    if {[info exists w]} {
        set wLen [llength $w]
    } else {
        set wLen [llength $x]
        set w [lrepeat $wLen 1]
    }
    set xiLen [llength $xi]
    if {$xLen!=$yLen} {
        error "Length of y '$yLen' must be equal to x '$xLen'"
    } elseif {$xLen!=$wLen} {
        error "Length of w '$wLen' must be equal to x '$xLen'"
    } elseif {$xiLen==0} {
        error "Length of interpolation points list xi must be more than zero"
    } elseif {[string is integer -strict $nterms]==0} {
        error "Number of terms -nterms '$nterms' must be of integer type"
    } elseif {$nterms<=0} {
        error "Number of terms -nterms must be more than zero"
    }
    ::tclinterp::lists2arrays [list xArray yArray wArray xiArray] [list $x $y $w $xi]
    ::tclinterp::newArrays [list b c d] [list $nterms $nterms $nterms]
    ::tclinterp::newDoubleps [list yiPnt yiDerPnt]
    # create polynomial coefficients for given data
    ::tclinterp::least_set $xLen $xArray $yArray $wArray $nterms $b $c $d
    # calculate polynomial value and derivative for each xi value
    for {set i 0} {$i<$xiLen} {incr i} {
        ::tclinterp::least_val2 $nterms $b $c $d [@ $xi $i] $yiPnt $yiDerPnt
        lappend yiList [::tclinterp::doublep_value $yiPnt]
        lappend yiDerList [::tclinterp::doublep_value $yiDerPnt]
    }
    if {[info exists coeffs]} {
        ::tclinterp::arrays2lists [list bList cList dList] [list $b $c $d] [list $nterms $nterms $nterms]
        ::tclinterp::deleteArrays $b $c $d $xArray $yArray $xiArray
        ::tclinterp::deleteDoubleps $yiPnt $yiDerPnt
        return [dcreate yi $yiList yiDer $yiDerList coeffs [dcreate b $bList c $cList d $dList]]
    } else {
        ::tclinterp::deleteArrays $b $c $d $xArray $yArray $xiArray
        ::tclinterp::deleteDoubleps $yiPnt $yiDerPnt
        return [dcreate yi $yiList yiDer $yiDerList]
    }
    return
}
.fi
.RE
.PP
.RS -4n
\fBinterpLin1d\fR (::tclinterp)
.RE
.PP
Does linear one-dimensional interpolation\&.
.RS 4n\fBinterpLin1d\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-x
List of independent variable (x) values, must be strictly increasing\&.
.TP
-xi
List of independent variable interpolation (xi) values\&.
.TP
-y
List of dependent variable (y) values\&.
.RE
.PP
\fBReturn value\fR
.PP
list of interpolated dependent variable values, yi, at xi
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::interpLin1d {args} {

    # Does linear one-dimensional interpolation\&.
    #  -x - list of independent variable (x) values, must be strictly increasing
    #  -y - list of dependent variable (y) values
    #  -xi - list of independent variable interpolation (xi) values
    # Returns: list of interpolated dependent variable values, `yi`, at `xi`
    set arguments [argparse {
        {-x= -required}
        {-y= -required}
        {-xi= -required}
    }]
    set xLen [llength $x]
    set yLen [llength $y]
    set xiLen [llength $xi]
    if {$xLen!=$yLen} {
        error "Length of y '$yLen' must be equal to x '$xLen'"
    } elseif {$xiLen==0} {
        error "Length of interpolation points list xi must be more than zero"
    }
    ::tclinterp::lists2arrays [list xArray yArray xiArray] [list $x $y $xi]
    if {[::tclinterp::r8vec_ascends_strictly $xLen $xArray]==0} {
        error "Independent variable array x not strictly increasing"
    }
    set yiArray [::tclinterp::interp_linear 1 $xLen $xArray $yArray $xiLen $xiArray]
    set yiList [::tclinterp::array2list $yiArray $xiLen]
    ::tclinterp::deleteArrays $xArray $yArray $xiArray $yiArray
    return $yiList
}
.fi
.RE
.PP
.RS -4n
\fBinterpNear1d\fR (::tclinterp)
.RE
.PP
Does nearest one-dimensional interpolation\&.
.RS 4n\fBinterpNear1d\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-x
List of independent variable (x) values\&.
.TP
-xi
List of independent variable interpolation (xi) values\&.
.TP
-y
List of dependent variable (y) values\&.
.RE
.PP
\fBReturn value\fR
.PP
list of interpolated dependent variable values, yi, at xi
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::interpNear1d {args} {

    # Does nearest one-dimensional interpolation\&.
    #  -x - list of independent variable (x) values
    #  -y - list of dependent variable (y) values
    #  -xi - list of independent variable interpolation (xi) values
    # Returns: list of interpolated dependent variable values, `yi`, at `xi`
    set arguments [argparse {
        {-x= -required}
        {-y= -required}
        {-xi= -required}
    }]
    set xLen [llength $x]
    set yLen [llength $y]
    set xiLen [llength $xi]
    if {$xLen!=$yLen} {
        error "Length of y '$yLen' must be equal to x '$xLen'"
    } elseif {$xiLen==0} {
        error "Length of interpolation points list xi must be more than zero"
    }
    ::tclinterp::lists2arrays [list xArray yArray xiArray] [list $x $y $xi]
    set yiArray [::tclinterp::interp_nearest 1 $xLen $xArray $yArray $xiLen $xiArray]
    set yiList [::tclinterp::array2list $yiArray $xiLen]
    ::tclinterp::deleteArrays $xArray $yArray $xiArray $yiArray
    return $yiList
}
.fi
.RE
.PP
.RS -4n
\fBlist2array\fR (::tclinterp)
.RE
.PP
Create and initialize doubleArray object from the list
.RS 4n\fBlist2array\fP \fIlist\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
list
List of values\&.
.RE
.PP
\fBReturn value\fR
.PP
array object
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::list2array {list} {

    # Create and initialize doubleArray object from the list
    #  list - list of values
    # Returns: array object
    set length [llength $list]
    set a [::tclinterp::new_doubleArray $length]
    for {set i 0} {$i<$length} {incr i} {
        set iElem [@ $list $i]
        try {
            ::tclinterp::doubleArray_setitem $a $i $iElem
        } on error {errmsg erropts} {
            if {[dget $erropts -errorcode]=="SWIG TypeError"} {
                error "List must contains only double elements, but get '$iElem'"
            } else {
                error "Array creation failed with message '$errmsg' and opts '$erropts'"
            }
        }
    }
    return $a
}
.fi
.RE
.PP
.RS -4n
\fBlists2arrays\fR (::tclinterp)
.RE
.PP
Create and initialize doubleArray objects from lists, and set these objects to variables
.RS 4n\fBlists2arrays\fP \fIvarNames lists\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
varNames
List of variables names\&.
.TP
lists
List of lists\&.
.RE
.PP
\fBReturn value\fR
.PP
variables with doubleArray objects are set in caller's scope
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::lists2arrays {varNames lists} {

    # Create and initialize doubleArray objects from lists, and set these objects to variables
    #  varNames - list of variables names
    #  lists - list of lists
    # Returns: variables with doubleArray objects are set in caller's scope
    if {[llength $varNames]!=[llength $lists]} {
        error "Length of varName list '[llength $varNames]' must be equal to length of lists list '[llength $lists]'"
    }
    foreach varName $varNames list $lists {
        uplevel 1 [list set $varName [::tclinterp::list2array $list]]
    }
    return
}
.fi
.RE
.PP
.RS -4n
\fBnewArrays\fR (::tclinterp)
.RE
.PP
Creates doubleArray objects, and set these objects to variables
.RS 4n\fBnewArrays\fP \fIvarNames lengths\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
varNames
List of variables names\&.
.TP
lengths
List of doubleArray's lengths\&.
.RE
.PP
\fBReturn value\fR
.PP
variables with doubleArray objects are set in caller's scope
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::newArrays {varNames lengths} {

    # Creates doubleArray objects, and set these objects to variables
    #  varNames - list of variables names
    #  lengths - list of doubleArray's lengths
    # Returns: variables with doubleArray objects are set in caller's scope
    if {[llength $varNames]!=[llength $lengths]} {
        error "Length of varName list '[llength $varNames]' must be equal to length of lengths list '[llength $lengths]'"
    }
    foreach varName $varNames length $lengths {
        uplevel 1 [list set $varName [::tclinterp::new_doubleArray $length]]
    }
    return
}
.fi
.RE
.PP
.RS -4n
\fBnewDoubleps\fR (::tclinterp)
.RE
.PP
Creates doubleps objects, and set these objects to variables
.RS 4n\fBnewDoubleps\fP \fIvarNames\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
varNames
List of variables names\&.
.RE
.PP
\fBReturn value\fR
.PP
variables with doubleps objects are set in caller's scope
.PP
\fBSource\fR
.PP
.RS 4n
.nf
proc ::tclinterp::newDoubleps {varNames} {

    # Creates doubleps objects, and set these objects to variables
    #  varNames - list of variables names
    # Returns: variables with doubleps objects are set in caller's scope
    foreach varName $varNames {
        uplevel 1 [list set $varName [::tclinterp::new_doublep]]
    }
    return
}
.fi
.RE

